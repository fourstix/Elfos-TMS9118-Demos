; -------------------------------------------------------------------
;                         slideshow
; Display a Sun Raster image files on the TMS9118 Video Card
; Supports uncompressed and RLE compressed raster image data.
;
; Copyright 2022 by Gaston Williams
; ------------------------------------------------------------------- 
; Program for the TMS9X18 Color Video Card driver and Elf/OS
;
; This program uses the TMS9X18 graphics mode 2 for bitmap display
; -------------------------------------------------------------------
; -------------------------------------------------------------------
; *** Uses BIOS calls from software written by Michael H Riley
; *** Original author copyright notice:
; -------------------------------------------------------------------
; *** This software is copyright 2004 by Michael H Riley          ***
; *** You have permission to use, modify, copy, and distribute    ***
; *** this software so long as this copyright notice is retained. ***
; *** This software may not be used in commercial applications    ***
; *** without express written permission from the author.         ***
; -------------------------------------------------------------------
;             TMS9118 / TMS9918
;            Graphics 2 memory map
;            +-----------------+ 0000h
;            |                 |
;            |  Pattern Table  |
;            |   6144 bytes    |
;            +-----------------+ 1800h
;            |                 |
;            | Sprite Patterns |
;            |    512 bytes    |
;            +-----------------+ 2000h
;            |                 |
;            |   Color Table   |
;            |   6144 bytes    |
;            +-----------------+ 3800h 
;            |                 |
;            |    Name Table   |
;            |    768 bytes    |
;            +-----------------+ 3B00h 
;            |                 |
;            |Sprite Attributes|
;            |    256 bytes    |
;            +-----------------+ 3C00h 
;            |                 |
;            |     Unused      |
;            |                 |
;            +-----------------+ 3FFFh 
;
; -------------------------------------------------------------------
;                     Sun Raster Image Format
;      32-byte header consisting of eight 4-byte Big Endian Integers
;      Followed by color map data as raw bytes (uncompressed or Sun rle)
;      Followed by bitmap data (uncompressed or Sun rle)
;
;     +-------------------+ 0000h 
;  1  | 59 | A6 | 6A | 95 |  Magic Number
;     +-------------------+ 0004h 
;  2  | 00 | 00 | 01 | 00 |  image width = 256 pixels
;     +-------------------+ 0008h 
;  3  | 00 | 00 | 00 | C0 |  image height = 192 pixels
;     +-------------------+ 000Ch 
;  4  | 00 | 00 | 00 | 01 |  image depth = 1 plane
;     +-------------------+ 0010h 
;  5  | 00 | 00 | aa | bb |  bitmap data length = aabbh (Uncompressed length is 1800h bytes)
;     +-------------------+ 0014h 
;  6  | 00 | 00 | 00 | xx |  data type xx: 01 = uncompressed, 02 = Sun rle compression
;     +-------------------+ 0018h 
;  7  | 00 | 00 | 00 | 02 |  color data type: 02 = raw data 
;     +-------------------+ 001Ch 
;  8  | 00 | 00 | cc | dd |  color map data length = ccddh (Uncompressed length is 1800h bytes)
;     +-------------------+ 0020h
;     |  Color Map Data   |  
;     +-------------------+ ccddh + 0020h (always 1820h for data type 01)
;     |    Bitmap Data    | 
;     +-------------------+ aabbh + cccch + 0020h (always 3020h for data type 01)
;
;     bytes 0-18 = magic number, image size must match exatly as shown above
;     byte 19 = data type, must be 01 or 02, anything else is an error
;     bytes 22,23 = bitmap data length (16 bit)
;     byte 27 = color map data type, must be 02 for raw color data (not rgb)
;     bytes 30,31 = color map data length (16 bit)
; -------------------------------------------------------------------

#include    include/bios.inc
#include    include/kernel.inc
#include    include/ops.inc
#include    include/vdp.inc

; declare external procedures in vdp_video library
            extrn  checkVideo
            extrn  beginG2Mode
            extrn  sendBmapData
            extrn  sendRleBmapData
            extrn  sendCmapData
            extrn  sendRleCmapData
            extrn  sendNames
            extrn  endG2Mode
            extrn  setGroup
            extrn  resetGroup


            ; Executable program header generated by linker

   org     02000h            ; Program code starts here
slideshow:  br      start    ; Jump past build information

            ; Build info
            db      80H+1    ; Month, 80H offset means extended info
            db      10       ; Day
            dw      2024     ; Year
            dw      7        ; Current build number

            ; Must end with 0 (null)
            db      'Copyright 2024 Gaston Williams',0

start:     mov     rf,next          ; point to dirents pointer
           mov     r7,dirents       ; dirents storage
           ldi     0                ; terminate list
           str     r7
           ghi     r7               ; store pointer
           str     rf
           inc     rf
           glo     r7
           str     rf
           call    docrlf           ; display a cr/lf
           ghi     ra
           phi     rf
           glo     ra
           plo     rf
sw_lp:     call    f_ltrim          ; move past leading whitespace
           ldn     rf               ; check for switches
           smi     '-'              ; which begin with -
           lbnz    no_sw            ; jump if no switches
           inc     rf               ; move to switch char
           lda     rf               ; retrieve switch
           smi     'r'              ; check for long mode
           lbnz    usage            ; unknown option show usage message
           load    rb, mode         ; point to modes variable
           ldi     0FFh
           str     rb               ; set mode to true to repeat
           call    f_ltrim          ; move past leading whitespace
no_sw:     load    rd, path         ; point to save path           
           call    f_strcpy         ; copy path into memory
           load    rf, path         ; check the path 
           ldn     rf
           lbz     get_path         ; if no path just skip check
find_end:  lda     rf
           lbnz    find_end           
           dec     rf               ; back up to null
           dec     rf               ; back up to last character
           lda     rf               ; check last character 
           smi     '/'
           lbz     get_path         ; path ends in slash,  okay to use
           ldi     '/'              ; otherwise add path separator
           str     rf
           inc     rf               ; advance to next character position     
           ldi     0                ; end with a null
           str     rf                              

get_path:  call checkVideo          ; check to see if TMS9X18 driver is loaded
           lbdf no_driver           ; if not loaded show msg and exit
 
           load    rf, path         ; point rf to path
           load    rd, fildes       ; set file descriptor for opendir
           call    o_opendir        ; open the directory

dirloop:   ldi     0                ; need to read 32 bytes
           phi     rc
           ldi     32
           plo     rc
           load    rf, buffer       ; setup transfer buffer
           load    rd, fildes       ; set file descriptor for read
           call    o_read           ; read files from dir
           glo     rc               ; see if eof was hit
           smi     32
           lbnz    dirdone          ; jump if done
           
           load    rf, buffer       ; set ptr to transfer buffer
           lda     rf               ; check for good entry
           lbnz    dirgood
           lda     rf               ; check for good entry
           lbnz    dirgood
           lda     rf               ; check for good entry
           lbnz    dirgood
           lda     rf               ; check for good entry
           lbnz    dirgood
           lbr     dirloop          ; not a valid entry, loop back
; *************************************************************
; *** Good entry found, copy needed data to dirents storage ***
; *************************************************************
dirgood:   load    rf, buffer+6     ; point to flags byte
           ldn     rf               ; retrieve it
           ani     $0B              ; check for sub-directory, hidden or executable
           lbz     noflags          ; jump if plain file
           lbr     dirloop          ; otherwise do not show it
noflags:   load    rf, next         ; need to retrieve next pointer
           lda     rf               ; put into rc
           phi     rc
           ldn     rf
           plo     rc               ; rc now points to blank space in dirents
           load    rf, buffer+12    ; point to filename
           ldi     19               ; 20 bytes per filename
           plo     re
namelp:    lda     rf               ; get next byte from name
           lbz     namedn           ; jump if name is done
           str     rc               ; store into dirents storage
           inc     rc
           dec     re               ; decrement count
           glo     re               ; check count
           lbnz    namelp           ; loop until all bytes copied
namedn:    ldi     0                ; write a string terminator
           str     rc
           inc     rc
             
; ***********************
; *** Done with entry ***
; ***********************
           ldi     0                ; write terminator into list
           str     rc
           load    rf, next         ; save new pointer
           ghi     rc
           str     rf
           inc     rf
           glo     rc
           str     rf
           lbr     dirloop          ; keep reading entries
           
; **************************************************************************
; *** Done reading directory, now it needs to be processed and displayed ***
; **************************************************************************
dirdone:   call o_close             ; close the directory
           
display:   mov  rf,dirents          ; point to dirents storage
displp:    ldn  rf                  ; rf points to next entry
           lbz  list_done           ; see if done with list
           
           PUSH rf                  ; save rf before copying string
           load rd, iname           ; point to image name
           call f_strcpy            ; copy to image name buffer
           POP  rf                  ; restore rf
           
           load rb, path            ; copy path in front of filename
           load rd, fname
           lda  rb
           lbz  cpy_name            ; if no path, just copy name                 
cpy_path:  str  rd                  ; put path character in filename
           inc  rd
           lda  rb                  ; get next character
           lbnz cpy_path            ; continue until last character copied         
cpy_name:  call f_strcpy            ; copy to filename buffer, rf points to dirent
           PUSH rf                  ; rf points to next entry in dirents, so save
        
showfile:  load rf, fname           
           load rd, fildes          ; set file descriptor
           ldi  0                   ; flags for open
           plo  r7
           call o_open              ; attempt to open file
           lbdf fskip               ; if can't open, try next file
                               
           load rc, HEADER_SIZE     ; try to read 32 byte header
           load rf, hbuffer         ; buffer to retrieve data
           load rd, fildes          ; set file descriptor
           call o_read              ; read the header
           lbdf fdone               ; if error, not a sun raster file
          
           load rf, hbuffer         ; buffer with header data
           load rd, sun_headr       ; load expected header values in rd
           load rc, 18              ; check first 18 bytes in header
           call memcmp              ; compare buffers
           lbnz fdone               ; if headers don't match, skip

           load rf, rtype           ; get the raster type byte
           lda  rf                  ; should be 01 or 02
           smi  01h                 ; check for 01 (uncompressed)
           lbz  rt_ok
           smi  01h                 ; check for 02 (rle compression)
           lbz  rt_ok           
           lbr  fdone               ; anything but 01 or 02 is not supported
            
rt_ok:     load rf, mtype           ; get color map type and verify it
           ldn  rf                  ; get the type byte from the header
           smi  02h                 ; validate that it is raw data
           lbnz fdone               ; any type except 02 is invalid
           
           load rf, iname           ; print image name
           call o_msg               ; print name without path onscreen
           call docrlf              ; one per line

           ; reading and writing bitmap data first reduces flash

           call seek_bmp            ; move file pointer to bitmap data
           load rf, bsize           ; get the size of bitmap data
           lda  rf                  ; get hi byte of bit map size
           phi  rc
           ldn  rf                  ; get lo byte of bit map size
           plo  rc             
           call read_data           ; read the bitmap data
           lbdf data_err            ; if error reading data, show msg

           ; write bitmap to display
             
           ldi  V_VDP_CLEAR         ; initialize memory card
           call beginG2Mode         ; set up video display
           load rf, rtype           ; check the type
           ldn  rf                  ; put the type in D 
           smi  01h                 ; 01 means uncompressed
           lbnz rle_bmp             ; 02 means rle compressed           
           call sendBmapData        ; send bitmap data to video card
           dw   dbuffer             ; bitmap data buffer
           dw   bsize               ; ptr to bitmap size in buffer           
           lbr  end_bmp 
rle_bmp:   call sendRleBmapData     ; send rle bitmap data to video card
           dw   dbuffer             ; bitmap data buffer
           dw   bsize               ; ptr to bitmap size in buffer
end_bmp:   call resetGroup          ; set expander card group back to default

           ; read color map
           
           call seek_clr            ; move file pointer to color map data
           load rf, csize           ; get the size of  color map data
           lda  rf                  ; get hi byte of color map size
           phi  rc
           ldn  rf                  ; get lo byte of color map size
           plo  rc
           call read_data           ; read the color table data
           lbdf data_err            ; if error, show msg

           load rd, fildes          ; set file descriptor
           call o_close             ; close the file

            
           ; update display with color map
           
           call setGroup            ; set expander card group for video card
           load rf, rtype           ; check the type
           ldn  rf                  ; put the type in D 
           smi  01h                 ; 01 means uncompressed
           lbnz rle_cmp             ; 02 means rle compressed
           call sendCmapData        ; send color map data
           dw   dbuffer             ; bitmap data buffer
           dw   csize               ; ptr to bitmap size in buffer           
           lbr  end_cmp 
rle_cmp:   call sendRleCmapData     ; send rle color map data to video card
           dw   dbuffer             ; bitmap data buffer
           dw   csize               ; ptr to bitmap size in buffer
end_cmp:   call sendNames           ; set color names
           call resetGroup          ; set expander card group back to default

           ; done updating display, set flag and wait a bit before continuing
           
           load rb, shown           ; point to shown flag
           ldi  0ffh                ; indicate at least one picture was shown
           str  rb                  ; set flag true

           load rc, 5               ; show display for a few seconds
wait:      glo  rc                  ; check outside loop counter
           lbnz cont
           ghi  rc
           lbnz cont                ; keep waiting until exhausted
           lbr  fskip               ; do next image after time out

quit:      POP  rf                  ; if input is pressed, clean up stack
           lbr  complete            ; and exit program
           
cont:      dec  rc
           load rf, 00h             ; set inner counter to max value
spin:      dec  rf
           b4   quit                ; if input pressed, quit waiting and exit  
           glo  rf
           lbnz spin                ; inner loop is about a second
           ghi  rf
           lbnz spin      
           lbr  wait                ; continue to wait before next image
           
           
data_err:  call O_INMSG
           db 'Bad image data',10,13,0           
fdone:     load rd, fildes          ; set file descriptor
           call o_close             ; close the file
fskip:     POP  rf                  ; restore rf to next pointer  
           lbr  displp              ; loop until all displaye

usage:     load rf, info0           ; show usage information
           call o_msg 
           load rf, info1
           call o_msg
           load rf, info2
           call o_msg
           load rf, info3
           call o_msg
           rtn                      ; exit to Elf/OSs

no_driver: load rf, nodriver
           call o_msg               ; show driver not loaded message
           rtn                      ; return to Elf/OS 
           
list_done: load rf, mode            ; check mode flag to repeat images
           ldn  rf
           lbz  complete            ; if not repeat mode, just exit
           load rf, shown           ; check if any images to show
           ldn  rf                  
           lbz  complete            ; if no images, just exit
           lbr  display             ; otherwise, display images again
                
complete:  call docrlf           
           ldi  V_VDP_KEEP          ; keep the vdp display on after exit
           call endG2Mode           ; set expander card group back to default                 
           rtn                      ; return to os

; ************************************************************
; docrlf -- Print a new line on screen
; ************************************************************   
docrlf:    call    o_inmsg
           db      10,13,0
           rtn                         ; and return

; ************************************************************
; read_data -- Read 0x1800 bytes of raster data.  
;              Used for the color map and bitmap data.
; Input: 
;   RC = Count of bytes to read (0x1800)
; Internal: 
;   RD = File descriptor
; Output:
;   RF = Pointer to buffer with data
;   DF = 0 Success
;   DF = 1 Error
; ************************************************************

read_data: load rd, fildes          ; put file descripter in rd
           load rf, dbuffer         ; set pointer to data buffer 
           call o_read              ; read the header
           lbdf rd_done             ; exit immediately, if read error
rd_done:   rtn

; ************************************************************
; seek_bmp -- Move file pointer to bitmap data  
;
; Input:             
;   R8 = High word of seek address
;   R7 = Low word of seek address
;   RC = Seek from (0 = beginning)
;   RD = File descriptor
; Output:
;   R8 = High word of file pointer
;   R7 = Low word of file pointer
;   DF = 0 Success
;   DF = 1 Error
; ************************************************************
         
seek_bmp:  load rf, csize         ; bitmap is after color map and header data
           lda  rf                ; get the high byte of color map size
           stxd                   ; store on stack
           irx                    ; point x back to data
           lda  rf                ; get the low byte of color map size 
           adi  020h              ; add the header size 
           plo  r7                ; put in seek size lo byte
           ldx                    ; get hi byte of csize from stack
           adci  00h              ; add in the carry flag if needed
           phi r7                 ; put in hi byte of seek size   
           load r8, 00h           ; set the seek offset
           load rc, 00h           ; seek from current
           load rd, fildes        ; set file descriptor
           call o_seek            ; move to bitmap data position
           rtn

; ************************************************************
; seek_clr -- Move file pointer to color map data  
;
; Input:             
;   R8 = High word of seek address
;   R7 = Low word of seek address
;   RC = Seek from (0 = beginning)
;   RD = File descriptor
; Output:
;   R8 = High word of file pointer
;   R7 = Low word of file pointer
;   DF = 0 Success
;   DF = 1 Error
; ************************************************************
       
seek_clr: load r8, 00h              ; set the seek offset
          load r7, COLORMAP_OFFSET  ; color map is after header data
          load rc, 00h              ; seek from beginning
          load rd, fildes           ; set file descriptor
          call o_seek               ; move to color map data position
          rtn

; ************************************************************
; memcmp -- Compare two memory arrays
;
; Inputs:
;   RF = pointer to array 1
;   RD = pointer to array 2
;   RC = number of byte to check 
; Output:
;   D = 0 -> arrays equal
;   D = 01 -> array 1 > array 2
;   D = FF -> array 1 < array 2
; ************************************************************
memcmp:   glo  rc          ; check count in RC
          lbnz mc_cont     ; count > 0, continue on
          ghi  rc          ; check count in RC
          lbz  mc_match    ; count = 0, arrays match
mc_cont:  dec  rc          ; check next byte
          lda  rd          ; get next byte in second string
          stxd             ; store into memory
          irx              ; point x back to memory 
          lda  rf          ; get byte from first string
          sm               ; subtract 2nd byte from it (D - MX)
          lbz   memcmp     ; so far a match, keep looking
          lbnf mc_grtr     ; jump if m1 byte is greater than m2
          ldi  0ffh        ; indicate first array is smaller
          lbr  mc_done     ; and return to caller
mc_grtr:  ldi  001h        ; indicate first array is larger
          lbr  mc_done     ; and return to caller
mc_match: ldi  0           ; arrays match
mc_done:  rtn              ; return to caller 

; -------------------------------------------------------------------
; Data Buffers and strings
; -------------------------------------------------------------------

           ; define 32-byte Sun Raster header data fields
sun_headr: db   059h, 0a6h, 06ah, 095h   ; magic number for Sun Raster format
           db   0,    0,    01h,  00h    ; image width = 256 pixels
           db   0,    0,    0,    0C0h   ; image height = 192 pixels
           db   0,    0,    0,    001h   ; image depth = 1 plane 
           db   0,    0    
           db   018h, 00h      ; length = 0x1800 or 6614 bytes
           db   0,    0,    0            
           db   01h            ; raster data type 1 = no compression
           db   0,    0,    0
           db   02h            ; color map type 2 = raw bytes (not rgb)
           db   0,    0
           db   018h, 00h      ; length = 0x1800 or 6614 bytes

mode:      db   0           ; flag to repeast slideshow loop
shown:     db   0           ; flag to indicate at least one picture shown
next:      dw   0           ; where to store dirents pointer
fildes:    db   0,0,0,0
           dw   dta
           db   0,0
           db   0
           db   0,0,0,0
           dw   0,0
           db   0,0,0,0
path:      db   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
iname:     ds   21
fname:     ds   41

           ; define constants for data in header  
hbuffer:   db   0, 0, 0, 0   ; magic number
           db   0, 0, 0, 0   ; image width
           db   0, 0, 0, 0   ; image height
           db   0, 0, 0, 0   ; image depth
           db   0, 0    
bsize:     db   0, 0         ; length = 0x1800 or 6614 bytes
           db   0, 0, 0
rtype:     db   0            ; data type 01 for standard, 02 for rle
           db   0, 0, 0
mtype:     db   0            ; color map type = 02 for raw bytes (not rgb)
           db   0, 0
csize:     db   0, 0         ; length = 0x1800 or 6614 bytes
buffer:    ds      32
nodriver:  db   'TMS9X18 Video driver is not loaded.',10,13,0
info0:     db   'Show all Sun raster image files in a directory.',10,13,0
info1:     db   'Usage: slideshow [-r][path]',10,13,0
info2:     db   '-r = repeat slideshow until input is pressed.',10,13,0
info3:     db   'path = directory for images (default is current directory)',10,13,0

dta:       ds   512
dbuffer:   ds   01800h       ; should be sufficient to hold rle and uncompressed data
overflow:  ds   256          ; but worse case rle can sometimes expand data slightly
dirents:   ds   768
      end slideshow
        
