; -------------------------------------------------------------------
;                         viewer
; Display a Sun Raster image file on the TMS9118 Video Card
; Supports uncompressed and RLE compressed raster image data.
;
; Copyright 2022 by Gaston Williams
; ------------------------------------------------------------------- 
; Program for the TMS9X18 Color Video Card driver and Elf/OS
;
; This program uses the TMS9118 graphics mode 2 for 'bitmap' display
; -------------------------------------------------------------------
; *** Based on software written by Glenn Jolly
; *** Original author copyright notice:
; Copyright (C) 2021 by Glenn Jolly;
; You have permission to use, modify, copy, and distribute
; this software for non commercial uses.  Please notify me 
; on the COSMAC ELF Group at https://groups.io/g/cosmacelf of any
; improvements and/or corrections.
; -------------------------------------------------------------------
; *** Uses BIOS calls from software written by Michael H Riley
; *** Original author copyright notice:
; -------------------------------------------------------------------
; *** This software is copyright 2004 by Michael H Riley          ***
; *** You have permission to use, modify, copy, and distribute    ***
; *** this software so long as this copyright notice is retained. ***
; *** This software may not be used in commercial applications    ***
; *** without express written permission from the author.         ***
; -------------------------------------------------------------------
;             TMS9118 / TMS9918
;            Graphics 2 memory map
;            +-----------------+ 0000h
;            |                 |
;            |  Pattern Table  |
;            |   6144 bytes    |
;            +-----------------+ 1800h
;            |                 |
;            | Sprite Patterns |
;            |    512 bytes    |
;            +-----------------+ 2000h
;            |                 |
;            |   Color Table   |
;            |   6144 bytes    |
;            +-----------------+ 3800h 
;            |                 |
;            |    Name Table   |
;            |    768 bytes    |
;            +-----------------+ 3B00h 
;            |                 |
;            |Sprite Attributes|
;            |    256 bytes    |
;            +-----------------+ 3C00h 
;            |                 |
;            |     Unused      |
;            |                 |
;            +-----------------+ 3FFFh 
;
; -------------------------------------------------------------------
;                     Sun Raster Image Format
;      32-byte header consisting of eight 4-byte Big Endian Integers
;      Followed by color map data as raw bytes (uncompressed or Sun rle)
;      Followed by bitmap data (uncompressed or Sun rle)
;
;     +-------------------+ 0000h 
;  1  | 59 | A6 | 6A | 95 |  Magic Number
;     +-------------------+ 0004h 
;  2  | 00 | 00 | 01 | 00 |  image width = 256 pixels
;     +-------------------+ 0008h 
;  3  | 00 | 00 | 00 | C0 |  image height = 192 pixels
;     +-------------------+ 000Ch 
;  4  | 00 | 00 | 00 | 01 |  image depth = 1 plane
;     +-------------------+ 0010h 
;  5  | 00 | 00 | aa | bb |  bitmap data length = aabbh (Uncompressed length is 1800h bytes)
;     +-------------------+ 0014h 
;  6  | 00 | 00 | 00 | xx |  data type xx: 01 = uncompressed, 02 = Sun rle compression
;     +-------------------+ 0018h 
;  7  | 00 | 00 | 00 | 02 |  color data type: 02 = raw data 
;     +-------------------+ 001Ch 
;  8  | 00 | 00 | cc | dd |  color map data length = ccddh (Uncompressed length is 1800h bytes)
;     +-------------------+ 0020h
;     |  Color Map Data   |  
;     +-------------------+ ccddh + 0020h (always 1820h for data type 01)
;     |    Bitmap Data    | 
;     +-------------------+ aabbh + cccch + 0020h (always 3020h for data type 01)
;
;     bytes 0-18 = magic number, image size must match exatly as shown above
;     byte 23 = data type, must be 01 or 02, anything else is an error
;     bytes 18,19 = bitmap data length (16 bit)
;     byte 27 = color map data type, must be 02 for raw color data (not rgb)
;     bytes 30,31 = color map data length (16 bit)
;

#include    include/bios.inc
#include    include/kernel.inc
#include    include/ops.inc
#include    include/vdp.inc

; uncomment this next line to show debug messages
;#define DEBUG_MSG      1       ; show debug messages


            ; declare external procedures in vdp_video library
            extrn  checkVideo
            extrn  beginG2Mode
            extrn  sendBmapData
            extrn  sendRleBmapData
            extrn  sendCmapData
            extrn  sendRleCmapData
            extrn  sendNames
            extrn  endG2Mode
            extrn  setGroup
            extrn  resetGroup


            ; Executable program header generated by linker
        org  02000h               ; Program code starts here
view:       br      start         ; Jump past build information

            ; Build information
            db      9+80H         ; Month, 80H offset means extended info
            db      1             ; Day
            dw      2022          ; Year
            dw      2             ; Build number 

            ; Must end with 0 (null)
            db      'Copyright 2022 Gaston Williams',0

start:      lda  ra                  ; move past any spaces
            smi  ' '
            lbz  start
            dec  ra                  ; move back to non-space character
            ghi  ra                  ; copy argument address to rf
            phi  rf
            glo  ra
            plo  rf
find_end:   lda  rf                  ; look for first less <= space
            smi  33
            lbdf find_end
            dec  rf                  ; backup to char
            ldi  0                   ; need proper termination
            str  rf
            ghi  ra                  ; back to beginning of name
            phi  rf
            glo  ra
            plo  rf
            ldn  rf                  ; get byte from argument
            lbz  usage               ; if no filename, show usage message
            
            call checkVideo          ; check to see if TMS9X18 driver is loaded
            lbdf no_driver           ; if not loaded show msg and exit
           
            load rd, fildes          ; get file descriptor
            ldi  0                   ; flags for open
            plo  r7
            call o_open              ; attempt to open file
            lbdf file_err            ; show error, if file was not opened

            load rc, HEADER_SIZE     ; try to read 32 byte header
            load rf, hbuffer         ; buffer to retrieve data
            call o_read              ; read the header
            lbdf headr_err           ; if error, not a sun raster file
           
            load rf, hbuffer         ; buffer with header data
            load rd, sun_headr       ; load expected header values in rd
            load rc, 18              ; check first 18 bytes in header
            call memcmp              ; compare buffers
            lbnz headr_err           ; if headers don't match show error
          
#ifdef DEBUG_MSG                   
            call o_inmsg             ; display header good message
            db   'Magic Number Good',10,13,0
#endif
         
            load rf, rtype           ; get the raster type byte
            lda  rf                  ; should be 01 or 02
            smi  01h                 ; check for 01 (uncompressed)
            lbz  rt_ok
            smi  01h                 ; check for 02 (rle compression)
            lbz  rt_ok           
            lbr  headr_err           ; anything but 01 or 02 is an errors
            
rt_ok:     
#ifdef DEBUG_MSG
            call o_inmsg             ; display data type message
            db  'Data type: ',0                
            load rf, rtype           ; get the data type byte from header
            ldn  rf           
            plo  rd                  ; put into RD.0 to convert from
            load rf, tbuffer         ; hexadecimal to 2 char ASCII
            call f_hexout2           
           
            load rf, tbuffer         ; Set up rf to point to string buffer
            call o_msg               ; output data type as text value
           
            call o_inmsg             ; display header good message
            db  10,13,0              ; print the end of the line
#endif
            load rf, mtype           ; get color map type and verify it
            ldn  rf                  ; get the type byte from the header
            smi  02h                 ; validate that it is raw data
            lbnz headr_err           ; any type except 02 is invalid

#ifdef DEBUG_MSG
            call o_inmsg             ; display header good message
            db  'Cmap type good',10,13,0
            call o_inmsg             ; display read message
            db   'Read bitmap',10,13,0
#endif           
           
            ; reading and writing bitmap data first reduces flash

            call seek_bmp            ; move file pointer to bitmap data
            load rf, bsize           ; get the size of bitmap data
            lda  rf                  ; get hi byte of bit map size
            phi  rc
            ldn  rf                  ; get lo byte of bit map size
            plo  rc             
            call read_data           ; read the bitmap data
            lbdf data_err            ; if error reading data, show msg

#ifdef DEBUG_MSG           
            call o_inmsg             ; display write message
            db   'Write bitmap',10,13,0
#endif

            call beginG2Mode         ; set up video display
            load rf, rtype           ; check the type
            ldn  rf                  ; put the type in D 
            smi  01h                 ; 01 means uncompressed
            lbnz rle_bmp             ; 02 means rle compressed           
            call sendBmapData        ; send bitmap data to video card
            dw   dbuffer             ; bitmap data buffer
            dw   bsize               ; ptr to bitmap size in buffer
            lbr  end_bmp 
rle_bmp:    call sendRleBmapData     ; send rle bitmap data to video card
            dw   dbuffer             ; bitmap data buffer
            dw   bsize               ; ptr to bitmap rle size in buffer
end_bmp:    call resetGroup          ; set expander card group back to default

#ifdef DEBUG_MSG           
            call o_inmsg             ; display read message
            db   'Read color map',10,13,0
#endif
           
            call seek_clr            ; move file pointer to color map data
            load rf, csize           ; get the size of  color map data
            lda  rf                  ; get hi byte of color map size
            phi  rc
            ldn  rf                  ; get lo byte of color map size
            plo  rc
            call read_data           ; read the color table data
            lbdf data_err            ; if error, show msg
                              
            load rd, fildes          ; set file descriptor
            call o_close             ; close the file
           
#ifdef DEBUG_MSG           
            call o_inmsg           ; otherwise display good message
            db   'Write color map',10,13,0
#endif
           
            ; update display with image bitmap
            call setGroup            ; set expander card group for video card
            load rf, rtype           ; check the type
            ldn  rf                  ; put the type in D 
            smi  01h                 ; 01 means uncompressed
            lbnz rle_cmp             ; 02 means rle compressed
            call sendCmapData        ; send color map data
            dw   dbuffer             ; bitmap data buffer
            dw   csize               ; ptr to bitmap size in buffer
            lbr  end_cmp 
rle_cmp:    call sendRleCmapData     ; send rle color map data to video card
            dw   dbuffer             ; bitmap data buffer
            dw   csize               ; ptr to bitmap size in buffer
end_cmp:    call sendNames           ; set color names
            ldi  V_VDP_KEEP          ; keep the vdp display on after exit
            call endG2Mode           ; set expander card group back to default

#ifdef DEBUG_MSG                       
            call o_inmsg           ; otherwise display good message
            db   'Done',10,13,0
#endif           
            lbr  done                ; return to Elf/OS

usage:      load rf, usage1          ; otherwise display usage message
            call o_msg             
            load rf, usage2       
            call o_msg
            lbr  done                ; return to Elf/OS
no_driver:  load rf, nodriver
            call o_msg               ; fall through to abend
            lbr  done                ; return to Elf/OS 
           

file_err:   load rf, nofile          ; get error message
            call o_msg
            lbr  err_exit            ; no file to close, exit to Elf/OS with error
           
data_err:   load  rf, baddata
            call o_msg
            lbr  abend               ; close and exit 
                    
headr_err:  load rf, badfile
            call o_msg               ; fall through to abend
                      
abend:      load rd, fildes          ; set file descriptor
            call o_close             ; close the file
err_exit:   ldi  0ffh                ; set error return value in D
done:       rtn                      ; return to os

 ; ************************************************************
 ; read_data -- Read 0x1800 bytes of raster data.  
 ;              Used for the color map and bitmap data.
 ; Input: 
 ;   RC = Count of bytes to read (0x1800)
 ; Internal: 
 ;   RD = File descriptor
 ; Output:
 ;   RF = Pointer to buffer with data
 ;   DF = 0 Success
 ;   DF = 1 Error
 ; ************************************************************

read_data:  load rd, fildes          ; put file descripter in rd
            load rf, dbuffer         ; set pointer to data buffer 
            call o_read              ; read the header
            lbdf rd_done             ; exit immediately, if read error
rd_done:    rtn

 ; ************************************************************
 ; seek_bmp -- Move file pointer to bitmap data  
 ;
 ; Input:             
 ;   R8 = High word of seek address
 ;   R7 = Low word of seek address
 ;   RC = Seek from (0 = beginning)
 ;   RD = File descriptor
 ; Output:
 ;   R8 = High word of file pointer
 ;   R7 = Low word of file pointer
 ;   DF = 0 Success
 ;   DF = 1 Error
 ; ************************************************************
           
seek_bmp:   load rf, csize         ; bitmap is after color map and header data
            lda  rf                ; get the high byte of color map size
            stxd                   ; store on stack
            irx                    ; point x back to data
            lda  rf                ; get the low byte of color map size 
            adi  020h              ; add the header size 
            plo  r7                ; put in seek size lo byte
            ldx                    ; get hi byte of csize from stack
            adci  00h              ; add in the carry flag if needed
            phi r7                 ; put in hi byte of seek size   
            load r8, 00h           ; set the seek offset
            load rc, 00h           ; seek from current
            load rd, fildes        ; set file descriptor
            call o_seek
            rtn

; ************************************************************
; seek_clr -- Move file pointer to color map data  
;
; Input:             
;   R8 = High word of seek address
;   R7 = Low word of seek address
;   RC = Seek from (0 = beginning)
;   RD = File descriptor
; Output:
;   R8 = High word of file pointer
;   R7 = Low word of file pointer
;   DF = 0 Success
;   DF = 1 Error
; ************************************************************
         
seek_clr:   load r8, 00h              ; set the seek offset
            load r7, COLORMAP_OFFSET  ; color map is after header data
            load rc, 00h              ; seek from beginning
            load rd, fildes           ; set file descriptor
            call o_seek
            rtn
               
; ************************************************************
; memcmp -- Compare two memory arrays
;
; Inputs:
;   RF = pointer to array 1
;   RD = pointer to array 2
;   RC = number of byte to check 
; Output:
;   D = 0 -> arrays equal
;   D = 01 -> array 1 > array 2
;   D = FF -> array 1 < array 2
; ************************************************************
memcmp:     glo  rc          ; check count in RC
            lbnz mc_cont     ; count > 0, continue on
            ghi  rc          ; check count in RC
            lbz  mc_match    ; count = 0, arrays match
mc_cont:    dec  rc          ; check next byte
            lda  rd          ; get next byte in second string
            stxd             ; store into memory
            irx              ; point x back to memory 
            lda  rf          ; get byte from first string
            sm               ; subtract 2nd byte from it (D - MX)
            lbz   memcmp     ; so far a match, keep looking
            lbnf mc_grtr     ; jump if m1 byte is greater than m2
            ldi  0ffh        ; indicate first array is smaller
            lbr  mc_done     ; and return to caller
mc_grtr:    ldi  001h        ; indicate first array is larger
            lbr  mc_done     ; and return to caller
mc_match:   ldi  0           ; arrays match
mc_done:    rtn              ; return to caller 

            ; define 32-byte Sun Raster header data fields
sun_headr:  db   059h, 0a6h, 06ah, 095h   ; magic number for Sun Raster format
            db   0,    0,    01h,  00h    ; image width = 256 pixels
            db   0,    0,    0,    0C0h   ; image height = 192 pixels
            db   0,    0,    0,    001h   ; image depth = 1 plane 
            db   0,    0,    0            
            db   01h            ; raster data type 1 = no compression
            db   0,    0    
            db   018h, 00h      ; length = 0x1800 or 6614 bytes
            db   0,    0,    0
            db   02h            ; color map type 2 = raw bytes (not rgb)
            db   0,    0
            db   018h, 00h      ; length = 0x1800 or 6614 bytes
 
nodriver:   db      'TMS9X18 Video driver is not loaded.',10,13,0
nofile:     db      'File not found',10,13,0
badfile:    db      'Invalid Sun Raster image file',10,13,0
baddata:    db      'Bad image data in file',10,13,0
usage1:     db      'Usage: view filename',10,13,0
usage2:     db      'Displays a Sun Raster image file.',10,13,0
fildes:     db      0,0,0,0
            dw      dta
            db      0,0
            db      0
            db      0,0,0,0
            dw      0,0
            db      0,0,0,0

            ; define constants for data in header  
hbuffer:    db   0, 0, 0, 0   ; magic number
            db   0, 0, 0, 0   ; image width
            db   0, 0, 0, 0   ; image height
            db   0, 0, 0, 0   ; image depth
            db   0, 0    
bsize:      db   0, 0         ; length = 0x1800 or 6614 bytes
            db   0, 0, 0
rtype:      db   0            ; data type 01 for standard, 02 for rle
            db   0, 0, 0
mtype:      db   0            ; color map type = 02 for raw bytes (not rgb)
            db   0, 0
csize:      db   0, 0         ; length = 0x1800 or 6614 bytes

#ifdef DEBUG_MSG
tbuffer:    db   0, 0, 0, 0   ; debug text
#endif            

            ; buffers outside of execution block
dta:        ds   512
dbuffer:    ds   01800h       ; should be sufficient to hold rle and uncompressed data
overflow:   ds   256          ; but worse case rle can sometimes expand data slightly
                              ; so reserve a page for overflow space in case this happens
        end view                     
